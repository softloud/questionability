---
title: "Validating the Graph Construction in the Simulation"
format: html
---

```{r}
# change the seed to change the validation
set.seed(45)
```

> Generated by Copilot.

This document walks through how we construct nodes and edges from a single simulated analysis, validating that the graph structure is correct before scaling up.

## Setup

```{r}
#| label: setup
#| message: false

library(targets)
library(dplyr)
library(tidyr)
library(purrr)

# Set project root (one level up from poc/)
project_root <- here::here()

# Load our functions from R/
for (f in list.files(file.path(project_root, "R"), full.names = TRUE, pattern = "\\.R$")) {
 source(f)
}

# Load pipeline objects we need
tar_load(simulated_analyses, store = file.path(project_root, "_targets"))
tar_load(column_index, store = file.path(project_root, "_targets"))
```

## A Single Analysis

Let's grab one analysis to understand the structure:

```{r}
#| label: single-analysis

single_analysis <- simulated_analyses |> sample_n(1)
single_analysis
```

This analysis has:

- **outcome_type**: `r single_analysis$outcome_type` 
- **source_cols**: `r length(single_analysis$source_cols[[1]])` columns used

```{r}
#| label: show-source-cols

# Which columns were used?
single_analysis$source_cols[[1]]

# Map to column names
column_index |> 

  filter(col_index %in% single_analysis$source_cols[[1]])
```

## Expected Graph Structure

For a single analysis with $n$ source columns:
 
- **Nodes**: 1 outcome node + $n$ source column nodes = $n + 1$ total
- **Edges**: 
  - $n$ source → outcome edges (each source column connects to the outcome)
  - $\binom{n}{2}$ source → source edges (all pairwise co-occurrences)

With `r length(single_analysis$source_cols[[1]])` source columns, we expect:

```{r}
#| label: expected-counts

n <- length(single_analysis$source_cols[[1]])

tibble(
  component = c("outcome nodes", "source_col nodes", "total nodes",
                "source→outcome edges", "source→source edges", "total edges"),
  expected = c(1, n, n + 1, n, choose(n, 2), n + choose(n, 2))
)
```

## Validating Nodes

```{r}
#| label: validate-nodes

node_val <- validate_single_nodes(single_analysis, column_index)

# Check results
tibble(
  check = names(node_val$checks),
  passed = unlist(node_val$checks)
)
```

The outcome node:

```{r}
#| label: outcome-node

node_val$outcome_nodes
```

The source column nodes:

```{r}
#| label: source-nodes

node_val$source_col_nodes
```

## Validating Edges

```{r}
#| label: validate-edges

edge_val <- validate_single_edges(single_analysis)

# Check results
tibble(
  check = names(edge_val$checks),
  passed = unlist(edge_val$checks)
)
```

Source → outcome edges (each source column connects to the outcome):

```{r}
#| label: so-edges

edge_val$source_outcome_edges
```

Source → source edges (pairwise co-occurrence):

```{r}
#| label: ss-edges

edge_val$source_source_edges
```

## All-in-One Validation

The `validate_single_analysis()` function runs all checks:

```{r}
#| label: full-validation

validation <- validate_single_analysis(single_analysis, column_index)

cat("All validations passed:", validation$all_passed, "\n")
```

## Validating the Graph Object

The final step is ensuring the `tbl_graph` object faithfully represents our nodes and edges. This checks that:

- Node and edge counts match
- All attributes are preserved (n_analyses, node_type, edge_type, outcome_counts)
- Edge from/to references resolve to valid nodes

```{r}
#| label: build-graph

library(tidygraph)

# Build graph from our validated nodes and edges
graph <- tbl_graph(
  nodes = node_val$nodes,
  edges = edge_val$edges
)

graph
```

```{r}
#| label: validate-graph

graph_val <- validate_graph_object(graph, node_val$nodes, edge_val$edges)

# Check results
tibble(
  check = names(graph_val$checks),
  passed = unlist(graph_val$checks)
)
```

The graph nodes:

```{r}
#| label: graph-nodes

graph_val$graph_nodes
```

The graph edges (note: from/to are now integer indices into the node table):

```{r}
#| label: graph-edges

graph_val$graph_edges
```

## Full Validation (All-in-One)

The `validate_full()` function runs nodes, edges, and graph validation together:

```{r}
#| label: validate-full

full_val <- validate_full(single_analysis, column_index)

cat("All validations passed:", full_val$all_passed, "\n")
```

## Why This Matters

When we aggregate across all `r nrow(simulated_analyses)` analyses:

- Nodes that appear in multiple analyses accumulate `n_analyses` counts
- Edges between frequently co-occurring variables have higher `n_analyses`
- The `outcome_counts` attribute tracks which outcomes each node/edge is associated with

This validation ensures the atomic unit (one analysis) produces the correct graph structure before we aggregate.
